# Splice It Up!
The idea is to de-noise the overwhelming database of assumed novel transcripts and to identify true novel transcripts of high confidence. Such true novel transcripts are the intersects of the novel transcripts confirmed by three approaches, which are the three main parts as described below.


# Detection of Novel Exons

It is clear from the proteomic diversity and functional complexity of higher order organisms 
the outdated model that one mRNA codes for one protein is implausible [REF]. 
Alternative splicing allows for a single mRNA to code for a variety of protein. 
Currently, there are a handful of computational tools [REF] available to detect novel splice junctions, 
but a common limitation among some of these tools includes the uncertainty of 
parsing biologically relevant splice junctions against experimental error. 
Additionally, there are very few methods that address investigating alternative splicing on long reads.

Here we propose a method discover novel splice junctions, both on short and long reads, 
and validate them against known exons in GENCODE and our own annotated data.

## Getting Started

Before use, it is recommended to preprocess your data (fastq? gtf?) through our metadata scripts (? and if so add link here) to ensure it is fit for analysis

### Prerequisites

input: GTF<br/>
dependencies: python 3.6.1, pandas, numpy, csv

```
add pipeline information here
```

### Verification of Novel Exons

To verify any novel exons in your data, run:
```
python detectNovelExons.py 
```
in the location of your experimental gtf files, as well as our transcript alignment file ( importTxAlignments.py , in tsv format. **Proprietary. BAM file available upon request **) and GenCode.

This code will filter your gtf file for known transcripts, any external exons, and retained introns. It will then compare the remaining
exons to unique transcript alignment exons. After successful run, three output files will appear in the directory of the script: 
1. _fileName_allExon.tsv: contains all filtered exons, not verified by the transcript alignment file
2. _fileName_ann.tsv: contains all filtered exons, not verified by the transcript alignment file
3. _fileName.log.out: contains information about the total number of exons, number of filtered exons, and number of verified filtered exons.

``` This script was run as multiple threads simultaneously by using glob patterns ERP* and SRP* ```

A gtf with roughly 715336 lines takes approximately 3-5 minutes to run (depending on the size of your transcript alignment file, or gencode)

Warning: The Gencode code is still underdevelopment and runs incredibly slow. Use at your own risk. Additionally, the retained intron function may remove relevant transcripts in an effort to be overly conservative. If the outputted exons are too low, I advise not using this function in the filtering step until improvements are made. 


# Detection of Novel Transcripts with TSS Support

One plausible approach to identify true novel transcripts is by searching for transcripts with alternative transcription start sites (TSSs). Intuitively, This pipline starts with extracting transcripts with at least one intron, and then extracts only the ones with the first exon (strand-specific) that is novel from these transcripts. The start positions (strand-specific*) of these novel first exons with standard unique identifiers are then plugged into the TSS database generated by FANTOM5; from here, the transcripts with the start position of novel first exon that is within a CAGE peak cluster or an extended CAGE peak cluster with user-defined distance are called and thus regarded as novel transcripts.

strand-specific*:if strand is -, then it is actually the last exon. Same notation applies to this entire section

## Getting Started 

Dependencies: python 3.6.4, csv, collections

### Command Line Samples

To extract nove transcripts that satisfy: 1) have at least 1 intron, 2) (strand-specifc) first exon is not referenced:
Input: .gtf file
```
python intronless_exon.py gtf_file.gtf
```
Output: exon_novel_gtf_file.gtf.tsv       (strand-specific*)
        (chr, strand, start of first exon, stop of first exon, strand, transcriptID)
        
Alternative: To extract nove transcripts that satisfy: 1) have at least 1 intron, 2) (strand-specific) first exon is not referenced:
Input: .gtf file, 3) the stop position of the (strand-specific) first exon does not match that of any of the referenced first exons.
```
python intronless_exon_endmatch.py gtf_file.gtf
```
Output: exon_novel_endmatch_gtf_file.gtf.tsv       (strand-specific*)
        (chr, strand, start of first exon, stop of first exon, strand, transcriptID)


To match the start(stop if anti-strand) positions of the exons outputed from above with a CAGE cluster / extended CAGE cluster:
```
python TSS_support.py exon_novel_gtf_file.gtf.tsv
```
Output: tight_novel_exon_novel_gtf_file.gtf.tsv.tsv     (strand-specific*)
        (chr, strand of transcript, transcriptID, strand of CAGE peak, CAGE peak ID)
        
To find p1 or p1-fusion CAGE peaks in the output file from the previos step:
```
bash p1_finder.sh
```
Output in shell: "tight_novel_exon_novel_gtf_file.gtf.tsv.tsv
                  x out of y"
                  where x = #transcripts with p1 peaks, y = #total transcripts.

# Detection of Novel Transcripts with intron structure



## Getting Started



### Prerequisites

input: GTFs, .tsv.gz alignment file <br/>
dependencies: python 3.6.1, pandas, numpy, csv , io, os, sys, gzip, argparse, signal, glob

```
python3 analyze_intron_structure.py
```
